diff --git client/decoders/src/h264.c client/decoders/src/h264.c
index c3abbbf..034edbe 100644
--- client/decoders/src/h264.c
+++ client/decoders/src/h264.c
@@ -127,7 +127,7 @@ static bool lgd_h264_create(void ** opaque)
   *opaque = malloc(sizeof(struct Inst));
   if (!*opaque)
   {
-    DEBUG_INFO("Failed to allocate %lu bytes", sizeof(struct Inst));
+    DEBUG_INFO("Failed to allocate %lu bytes", (unsigned long)sizeof(struct Inst));
     return false;
   }
   memset(*opaque, 0, sizeof(struct Inst));
@@ -978,4 +978,4 @@ const LG_Decoder LGD_H264 =
   .init_gl_texture   = lgd_h264_init_gl_texture,
   .free_gl_texture   = lgd_h264_free_gl_texture,
   .update_gl_texture = lgd_h264_update_gl_texture
-};
\ No newline at end of file
+};
diff --git client/decoders/src/null.c client/decoders/src/null.c
index bd30b55..32702d1 100644
--- client/decoders/src/null.c
+++ client/decoders/src/null.c
@@ -47,7 +47,7 @@ static bool lgd_null_create(void ** opaque)
   *opaque = malloc(sizeof(struct Inst));
   if (!*opaque)
   {
-    DEBUG_INFO("Failed to allocate %lu bytes", sizeof(struct Inst));
+    DEBUG_INFO("Failed to allocate %lu bytes", (unsigned long)sizeof(struct Inst));
     return false;
   }
   memset(*opaque, 0, sizeof(struct Inst));
@@ -127,4 +127,4 @@ const LG_Decoder LGD_NULL =
   .get_frame_stride = lgd_null_get_frame_stride,
   .decode           = lgd_null_decode,
   .get_buffer       = lgd_null_get_buffer
-};
\ No newline at end of file
+};
diff --git client/decoders/src/yuv420.c client/decoders/src/yuv420.c
index b4c1b86..1e39fc8 100644
--- client/decoders/src/yuv420.c
+++ client/decoders/src/yuv420.c
@@ -56,7 +56,7 @@ static bool lgd_yuv420_create(void ** opaque)
   *opaque = malloc(sizeof(struct Inst));
   if (!*opaque)
   {
-    DEBUG_INFO("Failed to allocate %lu bytes", sizeof(struct Inst));
+    DEBUG_INFO("Failed to allocate %lu bytes", (unsigned long)sizeof(struct Inst));
     return false;
   }
   memset(*opaque, 0, sizeof(struct Inst));
@@ -166,4 +166,4 @@ const LG_Decoder LGD_YUV420 =
   .init_gl_texture   = lgd_yuv420_init_gl_texture,
   .free_gl_texture   = lgd_yuv420_free_gl_texture,
   .update_gl_texture = lgd_yuv420_update_gl_texture
-};
\ No newline at end of file
+};
diff --git client/fonts/SDL/src/sdl.c client/fonts/SDL/src/sdl.c
index 9dbc7eb..2d44334 100644
--- client/fonts/SDL/src/sdl.c
+++ client/fonts/SDL/src/sdl.c
@@ -55,7 +55,7 @@ static bool lgf_sdl_create(LG_FontObj * opaque, const char * font_name, unsigned
   *opaque = malloc(sizeof(struct Inst));
   if (!*opaque)
   {
-    DEBUG_INFO("Failed to allocate %lu bytes", sizeof(struct Inst));
+    DEBUG_INFO("Failed to allocate %lu bytes", (unsigned long)sizeof(struct Inst));
     return false;
   }
   memset(*opaque, 0, sizeof(struct Inst));
@@ -150,4 +150,4 @@ struct LG_Font LGF_SDL =
   .destroy      = lgf_sdl_destroy,
   .render       = lgf_sdl_render,
   .release      = lgf_sdl_release
-};
\ No newline at end of file
+};
diff --git client/renderers/EGL/egl.c client/renderers/EGL/egl.c
index 27f0a1b..e7f9626 100644
--- client/renderers/EGL/egl.c
+++ client/renderers/EGL/egl.c
@@ -153,7 +153,7 @@ bool egl_create(void ** opaque, const LG_RendererParams params)
   *opaque = malloc(sizeof(struct Inst));
   if (!*opaque)
   {
-    DEBUG_INFO("Failed to allocate %lu bytes", sizeof(struct Inst));
+    DEBUG_INFO("Failed to allocate %lu bytes", (unsigned long)sizeof(struct Inst));
     return false;
   }
   memset(*opaque, 0, sizeof(struct Inst));
@@ -566,4 +566,4 @@ struct LG_Renderer LGR_EGL =
   .render_startup = egl_render_startup,
   .render         = egl_render,
   .update_fps     = egl_update_fps
-};
\ No newline at end of file
+};
diff --git client/renderers/EGL/texture.c client/renderers/EGL/texture.c
index ce9af86..f02c152 100644
--- client/renderers/EGL/texture.c
+++ client/renderers/EGL/texture.c
@@ -233,7 +233,7 @@ bool egl_texture_setup(EGL_Texture * texture, enum EGL_PixelFormat pixFmt, size_
 
       if (!texture->pboMap[i])
       {
-        DEBUG_ERROR("glMapBufferRange failed for %d of %lu bytes", i, texture->pboBufferSize);
+        DEBUG_ERROR("glMapBufferRange failed for %d of %lu bytes", i, (unsigned long)texture->pboBufferSize);
         return false;
       }
     }
@@ -362,4 +362,4 @@ enum EGL_TexStatus egl_texture_bind(EGL_Texture * texture)
 int egl_texture_count(EGL_Texture * texture)
 {
   return texture->textureCount;
-}
\ No newline at end of file
+}
diff --git client/renderers/OpenGL/opengl.c client/renderers/OpenGL/opengl.c
index a1f1bde..be9d4a2 100644
--- client/renderers/OpenGL/opengl.c
+++ client/renderers/OpenGL/opengl.c
@@ -193,7 +193,7 @@ bool opengl_create(void ** opaque, const LG_RendererParams params)
   *opaque = malloc(sizeof(struct Inst));
   if (!*opaque)
   {
-    DEBUG_INFO("Failed to allocate %lu bytes", sizeof(struct Inst));
+    DEBUG_INFO("Failed to allocate %lu bytes", (unsigned long)sizeof(struct Inst));
     return false;
   }
   memset(*opaque, 0, sizeof(struct Inst));
@@ -1371,7 +1371,7 @@ static bool draw_frame(struct Inst * this)
     if (check_gl_error("glTexSubImage2D"))
     {
       DEBUG_ERROR("texIndex: %u, width: %u, height: %u, vboFormat: %x, texSize: %lu",
-        this->texIndex, this->format.width, this->format.height, this->vboFormat, this->texSize
+        this->texIndex, this->format.width, this->format.height, this->vboFormat, (unsigned long)this->texSize
       );
     }
 
@@ -1415,4 +1415,4 @@ static void draw_mouse(struct Inst * this)
   glTranslatef(this->mousePos.x, this->mousePos.y, 0.0f);
   glCallList(this->mouseList);
   glPopMatrix();
-}
\ No newline at end of file
+}
diff --git client/spice/src/spice.c client/spice/src/spice.c
index 3436089..0eb3cd2 100644
--- client/spice/src/spice.c
+++ client/spice/src/spice.c
@@ -1303,7 +1303,7 @@ bool spice_read_nl(const struct SpiceChannel * channel, void * buffer, const ssi
     if (len <= 0)
     {
       if (len == 0)
-        DEBUG_ERROR("remote end closd connection after %ld byte(s)", size - left);
+        DEBUG_ERROR("remote end closd connection after %ld byte(s)", (long)(size - left));
       return false;
     }
     left -= len;
@@ -1325,7 +1325,7 @@ bool spice_discard_nl(const struct SpiceChannel * channel, ssize_t size)
     if (len <= 0)
     {
       if (len == 0)
-        DEBUG_ERROR("remote end closed connection after %ld byte(s)", size - left);
+        DEBUG_ERROR("remote end closed connection after %ld byte(s)", (long)size - left);
       free(c);
       return false;
     }
@@ -1664,4 +1664,4 @@ bool spice_clipboard_data(SpiceDataType type, uint8_t * data, size_t size)
 
   free(buffer);
   return true;
-}
\ No newline at end of file
+}
diff --git client/src/main.c client/src/main.c
index 9ce9384..193e581 100644
--- client/src/main.c
+++ client/src/main.c
@@ -314,7 +314,7 @@ static int frameThread(void * unused)
       DEBUG_WARN("  width  : %u"     , header.width  );
       DEBUG_WARN("  height : %u"     , header.height );
       DEBUG_WARN("  pitch  : %u"     , header.pitch  );
-      DEBUG_WARN("  dataPos: 0x%08lx", header.dataPos);
+      DEBUG_WARN("  dataPos: 0x%08lx", (long)header.dataPos);
       usleep(1000);
       continue;
     }
diff --git common/include/common/memcpySSE.h common/include/common/memcpySSE.h
index 848f517..8ea2e29 100644
--- common/include/common/memcpySSE.h
+++ common/include/common/memcpySSE.h
@@ -21,8 +21,24 @@ Place, Suite 330, Boston, MA 02111-1307 USA
 #include <stdbool.h>
 #include <stdint.h>
 #include <string.h>
-#include <tmmintrin.h>
-#include <immintrin.h>
+
+#if defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
+     /* GCC-compatible compiler, targeting x86/x86-64 */
+     #include <x86intrin.h>
+#elif defined(__GNUC__) && defined(__ARM_NEON__)
+     /* GCC-compatible compiler, targeting ARM with NEON */
+     #include <arm_neon.h>
+#elif defined(__GNUC__) && defined(__IWMMXT__)
+     /* GCC-compatible compiler, targeting ARM with WMMX */
+     #include <mmintrin.h>
+#elif (defined(__GNUC__) || defined(__xlC__)) && (defined(__VEC__) || defined(__ALTIVEC__))
+     /* XLC or GCC-compatible compiler, targeting PowerPC with VMX/VSX */
+     #include <altivec.h>
+#elif defined(__GNUC__) && defined(__SPE__)
+     /* GCC-compatible compiler, targeting PowerPC with SPE */
+     #include <spe.h>
+#endif
+
 
 #include "debug.h"
 
@@ -34,7 +50,7 @@ Place, Suite 330, Boston, MA 02111-1307 USA
   inline static void * memcpySSE(void *dst, const void * src, size_t length)
   {
     if (length == 0 || dst == src)
-      return;
+      return dst;
 
     // copies under 1MB are faster with the inlined memcpy
     // tell the dev to use that instead
@@ -47,7 +63,7 @@ Place, Suite 330, Boston, MA 02111-1307 USA
         smallBufferWarn = true;
       }
       memcpy(dst, src, length);
-      return;
+      return dst;
     }
 
     const void * end = dst + (length & ~0x7F);
@@ -129,6 +145,7 @@ Place, Suite 330, Boston, MA 02111-1307 USA
 
     //copy any remaining bytes
     memcpy(dst, src, length & 0xF);
+    return dst;
   }
 #else
   #define memcpySSE memcpy
